AWSTemplateFormatVersion: 2010-09-09

Description: >
  Bedrock template for DAT406 workshop - Fixed Lambda function names to avoid 64-char limit

Parameters:
  TemplateName:
    Type: String
    Default: genai-dat-406-labs

  VPC:
    Type: String
    Description: VPC ID for Lambda functions
  
  PrivateSubnets:
    Type: String
    Description: Comma-separated list of private subnet IDs
  
  VPCSecurityGroup:
    Type: String
    Description: Security group ID for database access
  
  DBCluster:
    Type: String
    Description: Aurora PostgreSQL cluster name
  
  DBClusterEndpoint:
    Type: String
    Description: Aurora PostgreSQL cluster endpoint
  
  RDSSecrets:
    Type: String
    Description: Secrets Manager secret ARN for database credentials
  
  AssetsBucketName:
    Type: String
    Description: S3 bucket containing assets
  
  AssetsBucketPrefix:
    Type: String
    Description: S3 prefix for assets

Resources:
  # ========================================
  # S3 Bucket for Knowledge Base
  # ========================================
  BedrockKB:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub "knowledgebase-dat406-${AWS::AccountId}"
      Tags:
        - Key: Workshop
          Value: DAT406

  # ========================================
  # IAM Roles and Policies
  # ========================================
  BedrockPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - "bedrock:InvokeModel"
              - "bedrock:ListCustomModels"
              - "bedrock:ListFoundationModels"
              - "bedrock:GetFoundationModel"
            Resource: "*"
          - Effect: Allow
            Action:
              - "secretsmanager:GetSecretValue"
              - "secretsmanager:DescribeSecret"
            Resource: "*"

  AmazonBedrockExecutionRoleForAgents:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${TemplateName}-BedrockRole"
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
        - arn:aws:iam::aws:policy/AmazonRDSFullAccess
        - arn:aws:iam::aws:policy/AmazonRDSDataFullAccess
        - !Ref BedrockPolicy

  LambdaBasicExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                  - "s3:PutObject"
                  - "s3:ListBucket"
                  - "s3:DeleteObject"
                Resource:
                  - !Sub "arn:aws:s3:::${BedrockKB}"
                  - !Sub "arn:aws:s3:::${BedrockKB}/*"
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "secretsmanager:GetSecretValue"
                Resource: !Ref RDSSecrets
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"

  # ========================================
  # Lambda Layer for psycopg
  # ========================================
  PsycopgLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub "${TemplateName}-psycopg-layer"
      Description: Psycopg layer for Bedrock Lambda functions
      Content:
        S3Bucket: !Ref AssetsBucketName
        S3Key: !Sub "${AssetsBucketPrefix}psycopg-layer.zip"
      CompatibleRuntimes:
        - python3.11

  # ========================================
  # Bedrock Agent Action Lambda - FIXED NAME
  # ========================================
  BedrockAgentActionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${TemplateName}-Agent-Lambda"  # SHORT NAME - 33 chars max
      Description: "API handler for DAT406 Bedrock Agent - manages product inventory"
      Layers:
        - !Ref PsycopgLayer
      Handler: index.lambda_handler
      Role: !GetAtt LambdaBasicExecutionRole.Arn
      Runtime: python3.11
      Timeout: 600
      MemorySize: 512
      VpcConfig:
        SecurityGroupIds:
          - !Ref VPCSecurityGroup
        SubnetIds: !Split [',', !Ref PrivateSubnets]
      Environment:
        Variables:
          DB_HOST: !Ref DBClusterEndpoint
          DB_NAME: postgres
          DB_USER: !Sub "{{resolve:secretsmanager:${RDSSecrets}:SecretString:username}}"
          DB_PASSWORD: !Sub "{{resolve:secretsmanager:${RDSSecrets}:SecretString:password}}"
      Code:
        ZipFile: |
          import json
          import os
          import asyncio
          import psycopg
          from psycopg.rows import dict_row
          from decimal import Decimal

          # Database connection parameters
          DB_HOST = os.environ['DB_HOST']
          DB_NAME = os.environ['DB_NAME']
          DB_USER = os.environ['DB_USER']
          DB_PASSWORD = os.environ['DB_PASSWORD']

          # Custom JSON encoder to handle Decimal
          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          async def get_products_inventory():
              """Retrieve product inventory from database"""
              async with await psycopg.AsyncConnection.connect(
                  f"host={DB_HOST} dbname={DB_NAME} user={DB_USER} password={DB_PASSWORD}",
                  row_factory=dict_row
              ) as aconn:
                  async with aconn.cursor() as acur:
                      await acur.execute("""
                          SELECT "productId", LEFT(product_description,100) as product_description, 
                                 stars, reviews, price, isbestseller, boughtinlastmonth, 
                                 category_name, quantity 
                          FROM bedrock_integration.product_catalog 
                          WHERE quantity IN (0, 1, 2, 3, 25, 70, 90) 
                          ORDER BY "productId" 
                          LIMIT 20;
                      """)
                      return await acur.fetchall()

          async def get_product_price(productId):
              """Get price for a specific product"""
              async with await psycopg.AsyncConnection.connect(
                  f"host={DB_HOST} dbname={DB_NAME} user={DB_USER} password={DB_PASSWORD}",
                  row_factory=dict_row
              ) as aconn:
                  async with aconn.cursor() as acur:
                      await acur.execute(
                          """SELECT "productId", product_description, price 
                             FROM bedrock_integration.product_catalog 
                             WHERE "productId" = %s;""",
                          (productId,)
                      )
                      return await acur.fetchone()

          async def restock_product(productId, quantity):
              """Restock a product by adding to its quantity"""
              async with await psycopg.AsyncConnection.connect(
                  f"host={DB_HOST} dbname={DB_NAME} user={DB_USER} password={DB_PASSWORD}",
                  row_factory=dict_row
              ) as aconn:
                  async with aconn.cursor() as acur:
                      try:
                          # Check if product exists
                          await acur.execute(
                              """SELECT "productId", quantity 
                                 FROM bedrock_integration.product_catalog 
                                 WHERE "productId" = %s;""",
                              (productId,)
                          )
                          product = await acur.fetchone()
                          
                          if not product:
                              return {"status": "Failure", "error": f"Product with ID {productId} not found"}
                          
                          # Update quantity
                          await acur.execute(
                              """UPDATE bedrock_integration.product_catalog 
                                 SET quantity = quantity + %s 
                                 WHERE "productId" = %s 
                                 RETURNING "productId", quantity;""",
                              (quantity, productId)
                          )
                          result = await acur.fetchone()
                          
                          if result:
                              await aconn.commit()
                              return {"status": "Success", "productId": result['productId'], "newQuantity": result['quantity']}
                          else:
                              await aconn.rollback()
                              return {"status": "Failure", "error": "Update operation did not return a result"}
                      except Exception as e:
                          await aconn.rollback()
                          print(f"Error restocking product: {str(e)}")
                          return {"status": "Failure", "error": str(e)}

          async def async_handler(event, context):
              """Main async handler for Lambda function"""
              print("Received event: " + json.dumps(event))
              
              api_path = event.get('apiPath', '/UnknownPath')
              
              if api_path == "/GetProductsInventory":
                  try:
                      response_data = await get_products_inventory()
                  except Exception as e:
                      print(f"Error querying database: {str(e)}")
                      response_data = {"error": "Failed to retrieve product inventory"}
              
              elif api_path == "/GetProductPrice":
                  print(f"Processing GetProductPrice request")
                  try:
                      productId = None
                      # Try to get productId from different possible locations
                      if event.get('queryStringParameters'):
                          productId = event['queryStringParameters'].get('productId')
                      if not productId and event.get('body'):
                          body = json.loads(event['body'])
                          productId = body.get('productId')
                      if not productId and event.get('requestBody'):
                          request_body = event.get('requestBody', {})
                          content = request_body.get('content', {})
                          json_content = content.get('application/json', {})
                          properties = json_content.get('properties', [])
                          params = {item['name']: item['value'] for item in properties if 'name' in item and 'value' in item}
                          productId = params.get('productId')
                              
                      print(f"Extracted productId: {productId}")
                              
                      if not productId:
                          print("productId not found in request")
                          response_data = {"error": "Missing productId parameter"}
                      else:
                          response_data = await get_product_price(productId)
                          if response_data:
                              print(f"Found product: {productId}")
                          else:
                              response_data = {"error": f"Product {productId} not found"}
                  except Exception as e:
                      print(f"Error processing GetProductPrice request: {str(e)}")
                      response_data = {"error": "Failed to retrieve product price"}
                      
              elif api_path == "/RestockProduct":
                  print(f"Processing RestockProduct request")
                  try:
                      # Extract parameters from request
                      request_body = event.get('requestBody', {})
                      content = request_body.get('content', {})
                      json_content = content.get('application/json', {})
                      properties = json_content.get('properties', [])
                      
                      params = {item['name']: item['value'] for item in properties if 'name' in item and 'value' in item}
                      
                      productId = params.get('productId')
                      quantity = params.get('quantity')
                      
                      print(f"Extracted parameters: productId={productId}, quantity={quantity}")
                      
                      if not productId:
                          raise ValueError("Missing productId parameter")
                      if quantity is None:
                          raise ValueError("Missing quantity parameter")
                      
                      try:
                          quantity = int(quantity)
                      except ValueError:
                          raise ValueError(f"Invalid quantity: '{quantity}' is not an integer")
                      
                      if quantity <= 0:
                          raise ValueError("Quantity must be a positive integer")
                      
                      response_data = await restock_product(productId, quantity)
                      print(f"Restock result: {json.dumps(response_data, cls=DecimalEncoder)}")
                  except ValueError as ve:
                      print(f"Validation error: {str(ve)}")
                      response_data = {"error": str(ve)}
                  except Exception as e:
                      print(f"Error processing RestockProduct request: {str(e)}")
                      response_data = {"error": f"Failed to restock product: {str(e)}"}
              else:
                  response_data = {"message": f"Unknown API Path: {api_path}"}

              # Format response for Bedrock Agent
              response_body = {
                  'application/json': {
                      'body': json.dumps(response_data, cls=DecimalEncoder)
                  }
              }
              
              action_response = {
                  'actionGroup': event.get('actionGroup', 'UnknownActionGroup'),
                  'apiPath': api_path,
                  'httpMethod': event.get('httpMethod', 'GET'),
                  'httpStatusCode': 200,
                  'responseBody': response_body
              }
              
              session_attributes = event.get('sessionAttributes', {})
              prompt_session_attributes = event.get('promptSessionAttributes', {})
              
              api_response = {
                  'messageVersion': '1.0', 
                  'response': action_response,
                  'sessionAttributes': session_attributes,
                  'promptSessionAttributes': prompt_session_attributes
              }
              
              print("Returning API response: " + json.dumps(api_response, cls=DecimalEncoder))
              return api_response

          def lambda_handler(event, context):
              """Main Lambda handler"""
              return asyncio.get_event_loop().run_until_complete(async_handler(event, context))

  BedrockAgentLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref BedrockAgentActionLambda
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"

  # ========================================
  # Bedrock Knowledge Base
  # ========================================
  AmazonBedrockAgentKnowledgebase:
    Type: AWS::Bedrock::KnowledgeBase
    Properties:
      Description: Bedrock Agent Knowledge Base for DAT406 Workshop
      KnowledgeBaseConfiguration:
        Type: VECTOR
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.titan-embed-text-v2:0"
          EmbeddingModelConfiguration:
            BedrockEmbeddingModelConfiguration:
              Dimensions: 1024
      Name: !Sub "${TemplateName}-kb"
      RoleArn: !GetAtt AmazonBedrockExecutionRoleForAgents.Arn
      StorageConfiguration:
        Type: RDS
        RdsConfiguration:
          ResourceArn: !Sub "arn:${AWS::Partition}:rds:${AWS::Region}:${AWS::AccountId}:cluster:${DBCluster}"
          CredentialsSecretArn: !Ref RDSSecrets
          DatabaseName: "postgres"
          TableName: "bedrock_integration.bedrock_kb"
          FieldMapping:
            MetadataField: "metadata"
            PrimaryKeyField: "id"
            TextField: "chunks"
            VectorField: "embedding"

  AmazonBedrockAgentDatasource:
    Type: AWS::Bedrock::DataSource
    DependsOn:
      - AmazonBedrockAgentKnowledgebase
    Properties:
      DataDeletionPolicy: DELETE
      DataSourceConfiguration:
        Type: S3
        S3Configuration:
          BucketArn: !GetAtt BedrockKB.Arn
          BucketOwnerAccountId: !Sub "${AWS::AccountId}"
      Description: "S3 Data Source for Bedrock Agent Knowledge Base"
      KnowledgeBaseId: !GetAtt AmazonBedrockAgentKnowledgebase.KnowledgeBaseId
      Name: !Sub "${TemplateName}-datasource"

  # ========================================
  # Bedrock Agent
  # ========================================
  AmazonBedrockAgent:
    Type: AWS::Bedrock::Agent
    DependsOn:
      - AmazonBedrockAgentDatasource
      - BedrockAgentActionLambda
    Properties:
      AgentName: !Sub "${TemplateName}-agent"
      ActionGroups:
        - ActionGroupName: "ProductInventoryActions"
          Description: "Actions for managing product inventory"
          ActionGroupExecutor:
            Lambda: !GetAtt BedrockAgentActionLambda.Arn
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Blaize Bazaar Product API",
                  "version": "1.0.0",
                  "description": "APIs for managing product inventory in Blaize Bazaar"
                },
                "paths": {
                  "/GetProductsInventory": {
                    "get": {
                      "summary": "Get products inventory",
                      "description": "Retrieves current inventory levels for products, limited to 20 items",
                      "operationId": "getProductsInventory",
                      "parameters": [],
                      "responses": {
                        "200": {
                          "description": "Successfully retrieved product inventory",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "productId": {
                                      "type": "string",
                                      "description": "Unique product identifier"
                                    },
                                    "product_description": {
                                      "type": "string",
                                      "description": "Product description (truncated to 100 chars)"
                                    },
                                    "stars": {
                                      "type": "number",
                                      "format": "float",
                                      "description": "Average product rating"
                                    },
                                    "reviews": {
                                      "type": "integer",
                                      "description": "Number of customer reviews"
                                    },
                                    "price": {
                                      "type": "number",
                                      "format": "float",
                                      "description": "Product price in USD"
                                    },
                                    "isbestseller": {
                                      "type": "boolean",
                                      "description": "Whether product is a bestseller"
                                    },
                                    "boughtinlastmonth": {
                                      "type": "integer",
                                      "description": "Units sold in the last month"
                                    },
                                    "category_name": {
                                      "type": "string",
                                      "description": "Product category"
                                    },
                                    "quantity": {
                                      "type": "integer",
                                      "description": "Current stock quantity"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "/GetProductPrice": {
                    "get": {
                      "summary": "Get product price",
                      "description": "Retrieves the current price for a specific product",
                      "operationId": "getProductPrice",
                      "parameters": [
                        {
                          "name": "productId",
                          "in": "query",
                          "required": true,
                          "schema": {
                            "type": "string"
                          },
                          "description": "The unique identifier of the product"
                        }
                      ],
                      "responses": {
                        "200": {
                          "description": "Successfully retrieved product price",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "productId": {
                                    "type": "string",
                                    "description": "Product identifier"
                                  },
                                  "product_description": {
                                    "type": "string",
                                    "description": "Full product description"
                                  },
                                  "price": {
                                    "type": "number",
                                    "format": "float",
                                    "description": "Current price in USD"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "404": {
                          "description": "Product not found",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "error": {
                                    "type": "string",
                                    "description": "Error message"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "/RestockProduct": {
                    "post": {
                      "summary": "Restock a product",
                      "description": "Adds quantity to the current stock of a specific product",
                      "operationId": "RestockProduct",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "required": ["productId", "quantity"],
                              "properties": {
                                "productId": {
                                  "type": "string",
                                  "description": "Product identifier to restock"
                                },
                                "quantity": {
                                  "type": "integer",
                                  "description": "Quantity to add to current stock (must be positive)"
                                }
                              }
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Product successfully restocked",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "status": {
                                    "type": "string",
                                    "description": "Operation status (Success or Failure)"
                                  },
                                  "productId": {
                                    "type": "string",
                                    "description": "Product identifier that was restocked"
                                  },
                                  "newQuantity": {
                                    "type": "integer",
                                    "description": "New total quantity after restocking"
                                  },
                                  "error": {
                                    "type": "string",
                                    "description": "Error message if operation failed"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "400": {
                          "description": "Bad Request - Invalid parameters",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "error": {
                                    "type": "string",
                                    "description": "Error message"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
      AgentResourceRoleArn: !GetAtt AmazonBedrockExecutionRoleForAgents.Arn
      Instruction: |
        You are a knowledgeable shopping assistant for Blaize Bazaar with real-time access to inventory data. 
        Your role is to guide customers through product selection with accurate stock information and personalized recommendations.
        
        Key responsibilities:
        - Provide current inventory levels and product availability
        - Suggest alternatives when items are low in stock
        - Ask clarifying questions to understand customer needs
        - Make personalized product recommendations based on preferences
        - Maintain a warm, professional, and helpful tone
        
        Communication style:
        - Use positive, solution-focused language
        - Instead of "I apologize", say "Let me help you find an alternative" or "Here's what we can do"
        - Be proactive in suggesting options when inventory is limited
        - Prioritize customer satisfaction while maintaining accuracy
      AutoPrepare: true
      Description: Shopping assistant agent for DAT406 workshop
      FoundationModel: us.anthropic.claude-3-7-sonnet-20250219-v1:0
      KnowledgeBases:
        - Description: "Product knowledge base"
          KnowledgeBaseId: !GetAtt AmazonBedrockAgentKnowledgebase.KnowledgeBaseId
          KnowledgeBaseState: ENABLED

  BedrockAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    DependsOn: AmazonBedrockAgent
    Properties:
      AgentAliasName: "latest"
      AgentId: !Ref AmazonBedrockAgent
      Description: "Latest version of the Bedrock Agent"

  # ========================================
  # Auto-ingestion Lambda for S3 events - FIXED NAME
  # ========================================
  KBAutoSyncLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockIngestionAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - "bedrock:StartIngestionJob"
                  - "bedrock:GetIngestionJob"
                  - "bedrock:ListIngestionJobs"
                Resource: "*"
        - PolicyName: S3ReadAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${BedrockKB}/*"
                  - !Sub "arn:aws:s3:::${BedrockKB}"

  KBAutoSyncLambda:
    Type: AWS::Lambda::Function
    DependsOn:
      - KBAutoSyncLambdaRole
      - AmazonBedrockAgentDatasource
      - AmazonBedrockAgentKnowledgebase
    Properties:
      FunctionName: !Sub "${TemplateName}-KBSync"  # SHORT NAME - 26 chars max
      Description: "Automatically syncs S3 changes to Bedrock Knowledge Base"
      Handler: index.lambda_handler
      Role: !GetAtt KBAutoSyncLambdaRole.Arn
      Runtime: python3.11
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          DATASOURCEID: !GetAtt AmazonBedrockAgentDatasource.DataSourceId
          KNOWLEDGEBASEID: !GetAtt AmazonBedrockAgentKnowledgebase.KnowledgeBaseId
      Code:
        ZipFile: |
          import os
          import json
          import boto3
          import time

          bedrockClient = boto3.client('bedrock-agent')

          def lambda_handler(event, context):
              """
              Triggered by S3 events to sync knowledge base
              """
              print('KB Auto Sync Lambda triggered')
              print(f'Event: {json.dumps(event)}')
              
              dataSourceId = os.environ['DATASOURCEID']
              knowledgeBaseId = os.environ['KNOWLEDGEBASEID']
              
              print(f'Knowledge Base ID: {knowledgeBaseId}')
              print(f'Data Source ID: {dataSourceId}')
              
              try:
                  # Start ingestion job
                  response = bedrockClient.start_ingestion_job(
                      knowledgeBaseId=knowledgeBaseId,
                      dataSourceId=dataSourceId,
                      description=f'Auto-sync triggered by S3 event at {time.strftime("%Y-%m-%d %H:%M:%S")}'
                  )
                  
                  ingestion_job_id = response.get('ingestionJob', {}).get('ingestionJobId', 'Unknown')
                  print(f'Started ingestion job: {ingestion_job_id}')
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Ingestion job started successfully',
                          'ingestionJobId': ingestion_job_id
                      })
                  }
                  
              except Exception as e:
                  print(f'Error starting ingestion job: {str(e)}')
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e)
                      })
                  }

  KBAutoSyncLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn: KBAutoSyncLambda
    Properties:
      FunctionName: !Ref KBAutoSyncLambda
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !GetAtt BedrockKB.Arn

  # ========================================
  # S3 Bucket Notification Configuration - FIXED NAME
  # ========================================
  BucketNotificationsCustomResource:
    Type: Custom::S3BucketNotifications
    DependsOn:
      - BedrockKB
      - KBAutoSyncLambda
      - KBAutoSyncLambdaPermission
    Properties:
      ServiceToken: !GetAtt NotificationSetupFunction.Arn
      BucketName: !Ref BedrockKB
      NotificationConfiguration:
        LambdaFunctionConfigurations:
          - LambdaFunctionArn: !GetAtt KBAutoSyncLambda.Arn
            Events:
              - s3:ObjectCreated:*
          - LambdaFunctionArn: !GetAtt KBAutoSyncLambda.Arn
            Events:
              - s3:ObjectRemoved:*

  NotificationSetupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3NotificationAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutBucketNotification
                  - s3:GetBucketNotification
                Resource: !GetAtt BedrockKB.Arn

  NotificationSetupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${TemplateName}-S3Notify"  # SHORT NAME - 28 chars max
      Description: "Custom resource to configure S3 bucket notifications"
      Handler: index.lambda_handler
      Role: !GetAtt NotificationSetupRole.Arn
      Runtime: python3.11
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          
          def lambda_handler(event, context):
              """
              Custom resource handler for S3 bucket notifications
              """
              try:
                  print(f'Event: {json.dumps(event)}')
                  
                  if event['RequestType'] == 'Delete':
                      # On stack deletion, just return success
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                      
                  if event['RequestType'] in ['Create', 'Update']:
                      s3 = boto3.client('s3')
                      bucket = event['ResourceProperties']['BucketName']
                      configuration = event['ResourceProperties']['NotificationConfiguration']
                      
                      print(f'Configuring notifications for bucket: {bucket}')
                      print(f'Configuration: {json.dumps(configuration)}')
                      
                      # Set bucket notification configuration
                      s3.put_bucket_notification_configuration(
                          Bucket=bucket,
                          NotificationConfiguration=configuration
                      )
                      
                      print('Bucket notifications configured successfully')
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': 'Bucket notifications configured'
                      })
                      
              except Exception as e:
                  print(f'Error: {str(e)}')
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })

# ========================================
# Outputs
# ========================================
Outputs:
  BedrockAgentId:
    Description: Bedrock Agent ID
    Value: !Ref AmazonBedrockAgent
    Export:
      Name: !Sub "${AWS::StackName}-BedrockAgentId"

  BedrockAgentAliasId:
    Description: Bedrock Agent Alias ID
    Value: !GetAtt BedrockAgentAlias.AgentAliasId
    Export:
      Name: !Sub "${AWS::StackName}-BedrockAgentAliasId"

  BedrockKnowledgeBaseId:
    Description: Bedrock Knowledge Base ID
    Value: !GetAtt AmazonBedrockAgentKnowledgebase.KnowledgeBaseId
    Export:
      Name: !Sub "${AWS::StackName}-BedrockKnowledgeBaseId"

  BedrockS3Bucket:
    Description: S3 bucket for Knowledge Base documents
    Value: !Ref BedrockKB
    Export:
      Name: !Sub "${AWS::StackName}-BedrockS3Bucket"

  BedrockAgentLambdaArn:
    Description: ARN of the Bedrock Agent Lambda Function
    Value: !GetAtt BedrockAgentActionLambda.Arn
    Export:
      Name: !Sub "${AWS::StackName}-BedrockAgentLambdaArn"

  BedrockAgentLambdaName:
    Description: Name of the Bedrock Agent Lambda Function
    Value: !Ref BedrockAgentActionLambda
    Export:
      Name: !Sub "${AWS::StackName}-BedrockAgentLambdaName"

  KBAutoSyncLambdaArn:
    Description: ARN of the KB Auto Sync Lambda Function
    Value: !GetAtt KBAutoSyncLambda.Arn
    Export:
      Name: !Sub "${AWS::StackName}-KBAutoSyncLambdaArn"