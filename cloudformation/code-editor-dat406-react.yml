---
AWSTemplateFormatVersion: 2010-09-09

Description: >
  Code Editor (VS Code Server) template for DAT406 with React development environment

Parameters:
  CodeEditorUser:
    Type: String
    Default: participant
    Description: Username for VS Code Server access

  InstanceName:
    Type: String
    Default: DAT406-CodeEditor
    Description: Name tag for the EC2 instance

  InstanceVolumeSize:
    Type: Number
    Default: 100
    MinValue: 40
    MaxValue: 500
    Description: EBS Volume size in GB

  InstanceType:
    Type: String
    Default: c6g.2xlarge
    AllowedValues:
      - t4g.medium
      - t4g.large
      - t4g.xlarge
      - c6g.xlarge
      - c6g.2xlarge
      - c6g.4xlarge
    Description: EC2 instance type (ARM-based for cost optimization)

  InstanceOperatingSystem:
    Type: String
    Default: AmazonLinux-2023
    AllowedValues:
      - AmazonLinux-2023
    Description: Operating System

  HomeFolder:
    Type: String
    Default: /workshop
    Description: Workshop home directory

  DevServerBasePath:
    Type: String
    Default: blaize-bazaar
    Description: React app directory name

  DevServerPort:
    Type: Number
    Default: 5173
    Description: React development server port

  RepoUrl:
    Type: String
    Default: https://github.com/aws-samples/sample-dat406-build-agentic-ai-powered-search-apg.git
    Description: Git repository URL for the workshop code

  VPCId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID where the instance will be deployed

  SubnetId:
    Type: AWS::EC2::Subnet::Id
    Description: Subnet ID for the EC2 instance

  VpcCIDR:
    Type: String
    Description: VPC CIDR block for security group rules

  DBSecretArn:
    Type: String
    Description: Aurora PostgreSQL database credentials secret ARN

  BedrockEmbeddingModel:
    Type: String
    Default: amazon.titan-embed-text-v2:0
    Description: Bedrock model for embeddings

  BedrockChatModel:
    Type: String
    Default: us.anthropic.claude-3-7-sonnet-20250219-v1:0
    Description: Bedrock model for chat

  AssetsBucketName:
    Type: String
    Description: S3 bucket containing workshop assets

  AssetsBucketPrefix:
    Type: String
    Description: S3 prefix for workshop assets

  PsycopgLayerArn:
    Type: String
    Description: ARN of the psycopg Lambda layer for PostgreSQL connectivity

  LatestAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-arm64
    Description: Latest Amazon Linux 2023 AMI ID for ARM64

Conditions:
  IsGraviton: !Not [
    !Equals [
      !Select [0, !Split ['g', !Select [0, !Split ['.', !Ref InstanceType]]]],
      !Select [0, !Split ['.', !Ref InstanceType]]
    ]
  ]
  HasDBSecret: !Not [!Equals [!Ref DBSecretArn, 'none']]

Mappings:
  AWSRegionsPrefixListID:
    us-east-1:
      PrefixList: pl-3b927c52
    us-west-2:
      PrefixList: pl-82a045eb
    eu-west-1:
      PrefixList: pl-4fa04526
    ap-northeast-1:
      PrefixList: pl-58a04531

Resources:
  # Generate password for Code Editor
  CodeEditorSecret:
    Type: AWS::SecretsManager::Secret
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Name: !Sub
      - ${InstanceName}-${RandomGUID}
      - RandomGUID: !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId ]]]]
      Description: Code Editor user details
      GenerateSecretString:
        PasswordLength: 16
        SecretStringTemplate: !Sub '{"username":"${CodeEditorUser}"}'
        GenerateStringKey: 'password'
        ExcludePunctuation: true

  # Lambda to get plaintext password
  SecretPlaintextLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AwsSecretsManager
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref CodeEditorSecret

  SecretPlaintextLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Return the value of the secret
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 10
      Architectures:
        - arm64
      Role: !GetAtt SecretPlaintextLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.debug(f'event: {event}')
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
                  else:
                      resource_properties = event['ResourceProperties']
                      secret_name = resource_properties['SecretArn']
                      secrets_mgr = boto3.client('secretsmanager')
                      secret = secrets_mgr.get_secret_value(SecretId = secret_name)
                      secret_value = json.loads(secret['SecretString'])
                      
                      responseData = {
                          'username': secret_value.get('username', 'participant'),
                          'password': secret_value.get('password', '')
                      }
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData=responseData, reason='OK', noEcho=True)
              except Exception as e:
                  logger.error(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  SecretPlaintext:
    Type: Custom::SecretPlaintextLambda
    Properties:
      ServiceToken: !GetAtt SecretPlaintextLambda.Arn
      ServiceTimeout: 15
      SecretArn: !Ref CodeEditorSecret

  # SSM Document for Code Editor Setup
  CodeEditorSSMDoc:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        description: Bootstrap Code Editor instance with React development environment
        parameters:
          CodeEditorPassword:
            type: String
            default: 'defaultPassword'
          DBSecretArn:
            type: String
            default: 'none'
        mainSteps:
          - name: InstallCloudWatchAgent
            action: aws:configurePackage
            inputs:
              name: AmazonCloudWatchAgent
              action: Install
          
          - name: ConfigureCloudWatchAgent
            action: aws:runDocument
            inputs:
              documentType: SSMDocument
              documentPath: AmazonCloudWatch-ManageAgent
              documentParameters:
                action: configure
                mode: ec2
                optionalConfigurationSource: default
                optionalRestart: 'yes'
          
          - name: InstallBasePackages
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - 'dnf install -y --allowerasing curl gnupg whois argon2 unzip nginx openssl jq git'
          
          - name: AddUser
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  echo 'Adding user: ${CodeEditorUser}'
                  adduser -c '' ${CodeEditorUser}
                  passwd -l ${CodeEditorUser}
                  echo "${CodeEditorUser}:{{ CodeEditorPassword }}" | chpasswd
                  usermod -aG wheel ${CodeEditorUser}
                  sed -i 's/# %wheel/%wheel/g' /etc/sudoers
                  echo "User added. Checking configuration"
                  getent passwd ${CodeEditorUser}
          
          - name: UpdateProfile
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - 'echo LANG=en_US.utf-8 >> /etc/environment'
                - 'echo LC_ALL=en_US.UTF-8 >> /etc/environment'
                - !Sub 'echo "PATH=$PATH:/home/${CodeEditorUser}/.local/bin" >> /home/${CodeEditorUser}/.bashrc'
                - !Sub 'echo "export PATH" >> /home/${CodeEditorUser}/.bashrc'
                - !Sub 'echo "export AWS_REGION=${AWS::Region}" >> /home/${CodeEditorUser}/.bashrc'
                - !Sub 'echo "export AWS_DEFAULT_REGION=${AWS::Region}" >> /home/${CodeEditorUser}/.bashrc'
                - !Sub 'echo "export AWS_ACCOUNTID=${AWS::AccountId}" >> /home/${CodeEditorUser}/.bashrc'
                - !Sub 'echo "export NEXT_TELEMETRY_DISABLED=1" >> /home/${CodeEditorUser}/.bashrc'
                - !Sub 'chown -R ${CodeEditorUser}:${CodeEditorUser} /home/${CodeEditorUser}'

          - name: InstallAWSCLI
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - 'mkdir -p /tmp'
                - 'curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-$(uname -m).zip -o /tmp/aws-cli.zip'
                - !Sub 'chown -R ${CodeEditorUser}:${CodeEditorUser} /tmp/aws-cli.zip'
                - 'unzip -q -d /tmp /tmp/aws-cli.zip'
                - 'sudo /tmp/aws/install'
                - 'rm -rf /tmp/aws'
                - 'echo "AWS CLI installed. Checking configuration"'
                - 'aws --version'
          
          - name: InstallGit
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub 'sudo -u ${CodeEditorUser} git config --global user.email "participant@example.com"'
                - !Sub 'sudo -u ${CodeEditorUser} git config --global user.name "Workshop Participant"'
                - !Sub 'sudo -u ${CodeEditorUser} git config --global init.defaultBranch "main"'
                - 'echo "Git installed. Checking configuration"'
                - 'git --version'
          
          - name: InstallNodeJS
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - 'echo "Installing Node.js 20..."'
                - 'curl -fsSL https://rpm.nodesource.com/setup_20.x | bash -'
                - 'dnf install -y nodejs'
                - 'npm install -g npm@latest'
                - 'node --version'
                - 'npm --version'
          
          - name: InstallPythonAndDeps
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 900
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - 'echo "Installing PostgreSQL 16 client and development tools..."'
                - |
                  # Try PostgreSQL 16 first, fallback to 15 if not available
                  if dnf list postgresql16 2>/dev/null; then
                      echo "Installing PostgreSQL 16 client..."
                      dnf install -y postgresql16 postgresql16-devel 2>&1
                  else
                      echo "PostgreSQL 16 not available, installing PostgreSQL 15..."
                      dnf install -y postgresql15 postgresql15-devel 2>&1
                  fi
                - 'echo "Installing Python 3.11 and development packages..."'
                - 'dnf install -y python3.11 python3.11-pip python3.11-devel gcc gcc-c++ make'
                - '/usr/bin/python3.11 -m pip install --upgrade pip'
                - 'echo "Installing Python packages for workshop..."'
                - 'echo "Note: psycopg layer is available for Lambda functions via the provided layer"'
                - '/usr/bin/python3.11 -m pip install boto3 pandas numpy scikit-learn python-dotenv fastapi uvicorn jupyter ipykernel'
                - 'echo "Installing psycopg2-binary for local development..."'
                - '/usr/bin/python3.11 -m pip install psycopg2-binary pgvector'
                - 'echo "Setting up Python alternatives..."'
                - 'alternatives --remove-all python 2>/dev/null || true'
                - 'alternatives --remove-all python3 2>/dev/null || true'
                - 'alternatives --install /usr/bin/python python /usr/bin/python3.11 100'
                - 'alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 100'
                - 'alternatives --set python /usr/bin/python3.11'
                - 'alternatives --set python3 /usr/bin/python3.11'
                - 'ln -sf /usr/bin/python3.11 /usr/local/bin/python'
                - 'ln -sf /usr/bin/python3.11 /usr/local/bin/python3'
                - 'echo "Verifying installations..."'
                - 'psql --version'
                - 'python --version'
          
          - name: SetupDatabaseEnvironment
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - 'echo "Setting up database environment..."'
                - !Sub |
                  if [[ "{{ DBSecretArn }}" != "none" ]]; then
                    echo "Configuring database connection..."
                    # Add database environment variables to bashrc
                    cat >> /home/${CodeEditorUser}/.bashrc << 'EOFDB'

                  # Auto-configure database connection for psql
                  if [ -n "$DB_SECRET_ARN" ] && [ "$DB_SECRET_ARN" != "none" ] && [ -z "$PGHOST" ]; then
                      SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id $DB_SECRET_ARN --query SecretString --output text --region ${AWS::Region} 2>/dev/null)
                      if [ $? -eq 0 ]; then
                          export PGHOST=$(echo $SECRET_VALUE | jq -r .host)
                          export PGPORT=$(echo $SECRET_VALUE | jq -r .port)
                          export PGUSER=$(echo $SECRET_VALUE | jq -r .username)
                          export PGPASSWORD=$(echo $SECRET_VALUE | jq -r .password)
                          export PGDATABASE=$(echo $SECRET_VALUE | jq -r 'if .dbname then .dbname else "postgres" end')
                          export DATABASE_URL="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE"
                          export DB_SECRET_ARN="{{ DBSecretArn }}"
                      fi
                  fi
                  EOFDB

                    # Create database connection test script
                    cat > /workshop/test_connection.py << 'EOFTEST'
                  #!/usr/bin/env python3
                  """
                  Test script for verifying database connection and pgvector setup
                  """
                  import os
                  import json
                  import boto3
                  import psycopg2
                  try:
                      from pgvector.psycopg2 import register_vector
                  except ImportError:
                      print("Installing pgvector...")
                      import subprocess
                      subprocess.check_call(["/usr/bin/python3.11", "-m", "pip", "install", "pgvector"])
                      from pgvector.psycopg2 import register_vector

                  def test_connection():
                      print("=" * 60)
                      print("Testing Aurora PostgreSQL Connection...")
                      print("=" * 60)

                      if os.environ.get('DB_SECRET_ARN') and os.environ.get('DB_SECRET_ARN') != 'none':
                          try:
                              region = os.environ.get('AWS_REGION', '${AWS::Region}')
                              client = boto3.client('secretsmanager', region_name=region)
                              response = client.get_secret_value(SecretId=os.environ['DB_SECRET_ARN'])
                              db_secrets = json.loads(response['SecretString'])

                              dbhost = db_secrets['host']
                              dbport = db_secrets['port']
                              dbuser = db_secrets['username']
                              dbpass = db_secrets['password']
                              dbname = db_secrets.get('dbname', 'postgres')

                              print(f"Connection Details:")
                              print(f"   Region: {region}")
                              print(f"   Host: {dbhost}")
                              print(f"   Port: {dbport}")
                              print(f"   Database: {dbname}")
                              print(f"   User: {dbuser}")
                              print("-" * 60)

                              conn = psycopg2.connect(
                                  host=dbhost,
                                  user=dbuser,
                                  password=dbpass,
                                  port=dbport,
                                  database=dbname,
                                  connect_timeout=10
                              )
                              register_vector(conn)

                              cur = conn.cursor()
                              cur.execute("SELECT version();")
                              version = cur.fetchone()
                              print(f"Successfully connected to Aurora PostgreSQL!")
                              print(f"   Version: {version[0].split(',')[0]}")

                              cur.execute("SELECT * FROM pg_extension WHERE extname = 'vector';")
                              if cur.fetchone():
                                  print(f"pgvector extension is installed and ready")
                              else:
                                  print(f"pgvector extension is NOT installed")

                              print("-" * 60)
                              print(f"Connection String:")
                              print(f"   postgresql://{dbuser}:****@{dbhost}:{dbport}/{dbname}")
                              print("-" * 60)
                              print(f"Quick psql commands:")
                              print(f"   psql                         - Connect to database")
                              print(f"   psql -c 'SELECT version()'   - Check version")

                              cur.close()
                              conn.close()

                              print("=" * 60)
                              print("Database connection test PASSED!")
                              print("=" * 60)
                              return True

                          except Exception as e:
                              print(f"Database connection FAILED: {e}")
                              print("=" * 60)
                              return False
                      else:
                          print("No database credentials configured")
                          print("=" * 60)
                          return False

                  if __name__ == "__main__":
                      test_connection()
                  EOFTEST
                    chmod +x /workshop/test_connection.py
                    chown ${CodeEditorUser}:${CodeEditorUser} /workshop/test_connection.py
                    echo "Database environment configured"
                  else
                    echo "No database secret provided, skipping database setup"
                  fi
          
          - name: SetupWorkshopDirectory
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub 'mkdir -p ${HomeFolder}'
                - !Sub 'chown -R ${CodeEditorUser}:${CodeEditorUser} ${HomeFolder}'
                - 'echo "Workshop directory created"'
          
          - name: SetupBlaizeBazaarApp
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 900
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub |
                  echo "Setting up Blaize Bazaar React application..."

                  # Download and extract the app
                  echo "Downloading blaize-bazaar.zip from S3..."
                  aws s3 cp s3://${AssetsBucketName}/${AssetsBucketPrefix}blaize-bazaar.zip /tmp/blaize-bazaar.zip

                  cd ${HomeFolder}
                  unzip -q /tmp/blaize-bazaar.zip
                  rm /tmp/blaize-bazaar.zip

                  # Fix any potential nested directory issues
                  if [ -d "blaize-bazaar/blaize-bazaar" ]; then
                    mv blaize-bazaar/blaize-bazaar/* blaize-bazaar/
                    rmdir blaize-bazaar/blaize-bazaar
                  fi

                  cd ${HomeFolder}/blaize-bazaar

                  # Configure vite for production build with correct base path
                  cat > vite.config.js <<'EOFVITE'
                  import { defineConfig } from 'vite'
                  import react from '@vitejs/plugin-react'

                  export default defineConfig({
                    plugins: [react()],
                    base: '/app/',
                    server: {
                      host: '0.0.0.0',
                      port: 5173,
                      strictPort: false,
                      allowedHosts: ['.cloudfront.net', 'localhost']
                    }
                  })
                  EOFVITE

                  # Create environment file
                  if [ "${DBSecretArn}" != "none" ]; then
                    SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id ${DBSecretArn} --query SecretString --output text --region ${AWS::Region})
                    DB_HOST=$(echo $SECRET_VALUE | jq -r .host)
                    DB_PORT=$(echo $SECRET_VALUE | jq -r .port)
                    DB_USER=$(echo $SECRET_VALUE | jq -r .username)
                    DB_NAME=$(echo $SECRET_VALUE | jq -r '.dbname // "postgres"')

                    cat > .env <<EOFENV
                  VITE_API_URL=http://localhost:8000
                  VITE_DB_HOST=$DB_HOST
                  VITE_DB_PORT=$DB_PORT
                  VITE_DB_NAME=$DB_NAME
                  VITE_DB_USER=$DB_USER
                  VITE_BEDROCK_EMBEDDING_MODEL=${BedrockEmbeddingModel}
                  VITE_BEDROCK_CHAT_MODEL=${BedrockChatModel}
                  VITE_AWS_REGION=${AWS::Region}
                  EOFENV
                  fi

                  # Install dependencies
                  echo "Installing npm dependencies..."
                  npm install

                  # Build the production app
                  echo "Building production app..."
                  npm run build

                  # Create the web directory
                  sudo mkdir -p /var/www/html/app

                  # Deploy the built app
                  echo "Deploying to /var/www/html/app..."
                  sudo cp -r dist/* /var/www/html/app/
                  sudo chown -R nginx:nginx /var/www/html/app || sudo chown -R www-data:www-data /var/www/html/app
                  sudo chmod -R 755 /var/www/html/app

                  # Create rebuild script for participants
                  cat > ${HomeFolder}/rebuild-app.sh <<'EOFREBUILD'
                  #!/bin/bash
                  echo "Rebuilding Blaize Bazaar app..."
                  cd ${HomeFolder}/blaize-bazaar
                  npm run build
                  sudo rm -rf /var/www/html/app/*
                  sudo cp -r dist/* /var/www/html/app/
                  sudo chown -R nginx:nginx /var/www/html/app || sudo chown -R www-data:www-data /var/www/html/app
                  echo "âœ… App rebuilt and deployed!"
                  echo "Access at: https://YOUR_CLOUDFRONT_URL/app/"
                  echo "Note: Use hard refresh (Cmd+Shift+R or Ctrl+Shift+R) to see changes"
                  EOFREBUILD
                  chmod +x ${HomeFolder}/rebuild-app.sh

                  # Set ownership
                  chown -R ${CodeEditorUser}:${CodeEditorUser} ${HomeFolder}

                  echo "âœ… Blaize Bazaar setup complete!"
                  echo "Production app will be available at: /app/"
                  echo "Development server can be started with: npm run dev"

          # Add these steps to your code-editor-dat406-react.yml after SetupBlaizeBazaarApp

          - name: LoadAmazonProductData
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 1800  # 30 minutes for data loading
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub |
                  echo "Setting up Amazon products database..."
                  
                  # Download the CSV file from S3
                  echo "Downloading product data..."
                  aws s3 cp s3://${AssetsBucketName}/${AssetsBucketPrefix}amazonproductssample.csv /workshop/amazonproductssample.csv
                  
                  # Create the data loading script
                  cat > /workshop/load_amazon_products.py << 'EOFLOADER'
                  [INSERT THE COMPLETE load_amazon_products.py CONTENT HERE]
                  EOFLOADER
                  
                  chmod +x /workshop/load_amazon_products.py
                  
                  # Set environment variables for the script
                  export DB_SECRET_ARN="${DBSecretArn}"
                  export AWS_REGION="${AWS::Region}"
                  export ASSETS_BUCKET="${AssetsBucketName}"
                  export ASSETS_PREFIX="${AssetsBucketPrefix}"
                  
                  # Run the data loading script
                  echo "Loading products into Aurora PostgreSQL..."
                  cd /workshop
                  python3 load_amazon_products.py
                  
                  echo "âœ… Product data loaded successfully!"
          
          - name: SetupBackendAPI
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub |
                  echo "Setting up FastAPI backend..."
                  
                  # Create backend directory
                  mkdir -p /workshop/backend
                  
                  # Create the FastAPI application
                  cat > /workshop/backend/app.py << 'EOFAPI'
                  [INSERT THE COMPLETE backend/app.py CONTENT HERE]
                  EOFAPI
                  
                  chmod +x /workshop/backend/app.py
                  
                  # Install Python dependencies for the API
                  pip install fastapi uvicorn psycopg2-binary pgvector boto3 pandas numpy
                  
                  # Create systemd service for the API
                  cat > /etc/systemd/system/blaize-api.service << 'EOFSERVICE'
                  [Unit]
                  Description=Blaize Bazaar API Service
                  After=network.target
                  
                  [Service]
                  Type=simple
                  User=${CodeEditorUser}
                  WorkingDirectory=/workshop/backend
                  Environment="PATH=/usr/bin:/usr/local/bin"
                  Environment="DB_SECRET_ARN=${DBSecretArn}"
                  Environment="AWS_REGION=${AWS::Region}"
                  Environment="PGHOST=$PGHOST"
                  Environment="PGPORT=$PGPORT"
                  Environment="PGUSER=$PGUSER"
                  Environment="PGPASSWORD=$PGPASSWORD"
                  Environment="PGDATABASE=$PGDATABASE"
                  ExecStart=/usr/local/bin/uvicorn app:app --host 0.0.0.0 --port 8000 --reload
                  Restart=always
                  
                  [Install]
                  WantedBy=multi-user.target
                  EOFSERVICE
                  
                  # Enable and start the API service
                  systemctl daemon-reload
                  systemctl enable blaize-api
                  systemctl start blaize-api
                  
                  echo "âœ… Backend API running on port 8000"
          
          - name: UpdateNginxForAPI
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub |
                  echo "Updating nginx configuration for API..."
                  
                  # Update nginx config to proxy API requests
                  cat > /etc/nginx/conf.d/react-app.conf << 'EOFNGINX'
                  server {
                      listen 80;
                      listen [::]:80;
                      server_name *.cloudfront.net;
                      
                      # VS Code server proxy
                      location / {
                        proxy_pass http://localhost:8080/;
                        proxy_set_header Host $host;
                        proxy_set_header Upgrade $http_upgrade;
                        proxy_set_header Connection upgrade;
                        proxy_set_header Accept-Encoding gzip;
                      }
                      
                      # React app static files
                      location /app/ {
                        alias /var/www/html/app/;
                        try_files $uri $uri/ /app/index.html;
                        index index.html;
                      }
                      
                      # API proxy
                      location /api/ {
                        proxy_pass http://localhost:8000/api/;
                        proxy_http_version 1.1;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                        
                        # CORS headers
                        add_header 'Access-Control-Allow-Origin' '*' always;
                        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
                        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
                      }
                  }
                  EOFNGINX
                  
                  # Restart nginx
                  systemctl restart nginx
                  
                  echo "âœ… Nginx updated with API proxy"
          
          - name: UpdateReactAppWithRealData
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub |
                  echo "Updating React app to use real data..."
                  
                  cd /workshop/blaize-bazaar
                  
                  # Update the App.jsx with the new version that uses real API
                  cat > src/App.jsx << 'EOFAPP'
                  [INSERT THE UPDATED App.jsx CONTENT HERE]
                  EOFAPP
                  
                  # Rebuild the app
                  npm run build
                  
                  # Deploy the updated app
                  rm -rf /var/www/html/app/*
                  cp -r dist/* /var/www/html/app/
                  chown -R nginx:nginx /var/www/html/app || chown -R www-data:www-data /var/www/html/app
                  
                  echo "âœ… React app updated with real data integration!"
          
          - name: CreateWorkshopTestScripts
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  # Create test script for semantic search
                  cat > /workshop/test_semantic_search.py << 'EOFTEST'
                  #!/usr/bin/env python3
                  """Test semantic search functionality"""
                  
                  import requests
                  import json
                  import time
                  
                  API_URL = "http://localhost:8000/api"
                  
                  def test_search(query):
                      """Test semantic search"""
                      print(f"\nðŸ” Searching for: '{query}'")
                      
                      start = time.time()
                      response = requests.post(f"{API_URL}/search", json={
                          "query": query,
                          "limit": 5
                      })
                      
                      if response.status_code == 200:
                          data = response.json()
                          print(f"âœ… Found {len(data['products'])} products in {data['query_time_ms']:.1f}ms")
                          
                          for i, product in enumerate(data['products'][:3], 1):
                              print(f"\n{i}. {product['product_description'][:100]}...")
                              print(f"   Price: ${product['price']:.2f}")
                              print(f"   Rating: {product['stars']}â­ ({product['reviews']} reviews)")
                              print(f"   Similarity: {product['similarity_score']*100:.1f}%")
                      else:
                          print(f"âŒ Search failed: {response.status_code}")
                  
                  # Test different queries
                  test_queries = [
                      "wireless headphones",
                      "laptop for programming",
                      "coffee maker",
                      "yoga mat",
                      "smart watch"
                  ]
                  
                  for query in test_queries:
                      test_search(query)
                      time.sleep(1)
                  
                  print("\nâœ… All tests completed!")
                  EOFTEST
                  
                  chmod +x /workshop/test_semantic_search.py
                  
                  # Create a simple status check script
                  cat > /workshop/check_status.sh << 'EOFSTATUS'
                  #!/bin/bash
                  echo "==================================="
                  echo "   Blaize Bazaar Status Check"
                  echo "==================================="
                  
                  # Check API
                  echo -n "API Service: "
                  if systemctl is-active --quiet blaize-api; then
                      echo "âœ… Running"
                      curl -s http://localhost:8000/ | jq .
                  else
                      echo "âŒ Not running"
                  fi
                  
                  # Check database
                  echo -n "Database: "
                  if python3 -c "import psycopg2; psycopg2.connect(host='$PGHOST', port='$PGPORT', user='$PGUSER', password='$PGPASSWORD', database='$PGDATABASE')" 2>/dev/null; then
                      echo "âœ… Connected"
                      psql -c "SELECT COUNT(*) as products, COUNT(embedding) as with_embeddings FROM products;" 2>/dev/null
                  else
                      echo "âŒ Not connected"
                  fi
                  
                  # Check nginx
                  echo -n "Nginx: "
                  if systemctl is-active --quiet nginx; then
                      echo "âœ… Running"
                  else
                      echo "âŒ Not running"
                  fi
                  
                  echo ""
                  echo "Access your app at: https://YOUR_CLOUDFRONT_URL/app/"
                  echo "==================================="
                  EOFSTATUS
                  
                  chmod +x /workshop/check_status.sh
                  
                  echo "âœ… Workshop test scripts created!"
                  echo ""
                  echo "To test your setup:"
                  echo "  ./check_status.sh              - Check all services"
                  echo "  python test_semantic_search.py - Test vector search"
                  echo ""
          
          - name: InstallCodeEditor
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub 'export CodeEditorUser=${CodeEditorUser}'
                - 'curl -fsSL https://code-editor.amazonaws.com/content/code-editor-server/dist/aws-workshop-studio/install.sh | bash -s -- 2>&1 || { echo "Code Editor installation failed"; exit 1; }'
          
          - name: ConfigureNginx
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - 'echo "Configuring nginx..."'
                - !Sub |
                  # Create the exact working configuration
                  cat > /etc/nginx/conf.d/react-app.conf <<'EOF'
                  server {
                      listen 80;
                      listen [::]:80;
                      server_name *.cloudfront.net;

                      # Existing VS Code server proxy
                      location / {
                        proxy_pass http://localhost:8080/;
                        proxy_set_header Host $host;
                        proxy_set_header Upgrade $http_upgrade;
                        proxy_set_header Connection upgrade;
                        proxy_set_header Accept-Encoding gzip;
                      }

                      # New location for React app
                      location /app/ {
                        alias /var/www/html/app/;
                        try_files $uri $uri/ /app/index.html;
                        index index.html;
                      }
                  }
                  EOF

                  # Ensure web directory exists
                  mkdir -p /var/www/html/app
                  chown -R nginx:nginx /var/www/html || chown -R www-data:www-data /var/www/html

                  # Enable and restart nginx
                  systemctl enable nginx
                  systemctl restart nginx
                  echo "Nginx configured successfully"
          
          - name: ConfigureAuthToken
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - !Sub |
                  sudo -u ${CodeEditorUser} --login mkdir -p /home/${CodeEditorUser}/.code-editor-server/data
                  sudo -u ${CodeEditorUser} --login touch /home/${CodeEditorUser}/.code-editor-server/data/token
                  echo -n "{{ CodeEditorPassword }}" > /home/${CodeEditorUser}/.code-editor-server/data/token
          
          - name: CreateCodeEditorSettings
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - !Sub 'sudo -u ${CodeEditorUser} --login mkdir -p /home/${CodeEditorUser}/.code-editor-server/data/User'
                - !Sub |
                  tee /home/${CodeEditorUser}/.code-editor-server/data/User/settings.json <<EOF
                  {
                    "workbench.colorTheme": "Default Dark Modern",
                    "git.enabled": false,
                    "git.decorations.enabled": false,
                    "aws.telemetry": false,
                    "extensions.autoUpdate": false,
                    "telemetry.telemetryLevel": "off",
                    "security.workspace.trust.startupPrompt": "never",
                    "security.workspace.trust.enabled": false,
                    "terminal.integrated.cwd": "${HomeFolder}",
                    "terminal.integrated.defaultProfile.linux": "bash",
                    "python.defaultInterpreterPath": "/usr/bin/python3.11",
                    "auto-run-command.rules": [
                      {
                        "command": "workbench.action.terminal.new",
                        "finalization": true
                      }
                    ],
                    "workbench.action.terminal.focus": true,
                    "terminal.integrated.automationProfile.linux": {
                      "path": "/bin/bash"
                    }
                  }
                  EOF
                - !Sub 'chown -R ${CodeEditorUser}:${CodeEditorUser} /home/${CodeEditorUser}'
                - !Sub 'systemctl enable --now code-editor@${CodeEditorUser}'
                - !Sub 'systemctl restart code-editor@${CodeEditorUser}'

          - name: InstallCodeEditorExtensions
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 900
              runCommand:
                - '#!/bin/bash'
                - 'set -euo pipefail'
                - !Sub |
                  function install_extension() {
                    local extension_name=$1
                    echo "Installing extension: $extension_name"
                    if ! sudo -u ${CodeEditorUser} --login code-editor-server --install-extension "$extension_name" --force; then
                        echo "Failed to install $extension_name, continuing..."
                        return 1
                    fi
                    echo "Successfully installed $extension_name"
                    return 0
                  }
                  
                  # Essential AWS and development extensions
                  echo "Installing essential VS Code extensions..."
                  install_extension "AmazonWebServices.aws-toolkit-vscode"
                  install_extension "AmazonWebServices.amazon-q-vscode"
                  install_extension "ms-python.python"
                  install_extension "ms-python.vscode-pylance"
                  install_extension "ms-toolsai.jupyter"
                  install_extension "synedra.auto-run-command"
                  install_extension "ms-vscode.live-server"
                  install_extension "bradlc.vscode-tailwindcss"
                  install_extension "esbenp.prettier-vscode"
                  install_extension "ms-vscode.vscode-json"
                  install_extension "ms-vscode.vscode-typescript-next"
                  install_extension "ms-vscode.vscode-html-language-features"
                  install_extension "ms-vscode.vscode-css-language-features"
                  
                  # Database extensions
                  install_extension "ms-mssql.mssql" || echo "SQL extension not available"
                  install_extension "cweijan.vscode-postgresql-client2" || echo "PostgreSQL extension not available"
                  
                  echo "Extension installation completed"
                - !Sub 'chown -R ${CodeEditorUser}:${CodeEditorUser} /home/${CodeEditorUser}'
                - !Sub 'systemctl status code-editor@${CodeEditorUser}'

          - name: CreateStartupMessage
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  # Create startup script with helpful information
                  cat > /home/${CodeEditorUser}/.workshop_startup.sh <<'EOFSTARTUP'
                  #!/bin/bash

                  # Only show on first terminal
                  if [ -z "$WORKSHOP_STARTED" ]; then
                    export WORKSHOP_STARTED=1

                    clear
                    echo ""
                    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
                    echo "â•‘        ðŸš€ Welcome to DAT406 - Blaize Bazaar Workshop! ðŸš€        â•‘"
                    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                    echo "ðŸ“± Your app is already running!"
                    echo "   â””â”€> Access at: https://YOUR_CLOUDFRONT_URL/app/"
                    echo ""
                    echo "ðŸ”§ Quick Commands:"
                    echo "   â€¢ Rebuild app after changes:  ~/rebuild-app.sh"
                    echo "   â€¢ Start dev server:           cd ~/blaize-bazaar && npm run dev"
                    echo "   â€¢ Test database:              python ~/test_connection.py"
                    echo "   â€¢ Connect to PostgreSQL:      psql"
                    echo ""
                    echo "ðŸ“‚ Project Structure:"
                    echo "   ~/blaize-bazaar/         Your React application"
                    echo "   /var/www/html/app/       Deployed production build"
                    echo ""
                    echo "ðŸ’¡ Tips:"
                    echo "   â€¢ Use Cmd+Shift+R (Mac) or Ctrl+Shift+R (PC) for hard refresh"
                    echo "   â€¢ Add ?v=1, ?v=2 etc to URL to bypass cache"
                    echo ""

                    # Test database connection if script exists
                    if [ -f "${HomeFolder}/test_connection.py" ]; then
                      echo "Testing database connection..."
                      python ${HomeFolder}/test_connection.py 2>/dev/null || echo "Database connection pending..."
                    fi

                    echo ""
                    echo "Ready to build amazing AI-powered search with Aurora PostgreSQL!"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  fi
                  EOFSTARTUP

                  chmod +x /home/${CodeEditorUser}/.workshop_startup.sh
                  chown ${CodeEditorUser}:${CodeEditorUser} /home/${CodeEditorUser}/.workshop_startup.sh

                  # Add to bashrc
                  echo "" >> /home/${CodeEditorUser}/.bashrc
                  echo "# Workshop startup" >> /home/${CodeEditorUser}/.bashrc  
                  echo "[ -f ~/.workshop_startup.sh ] && source ~/.workshop_startup.sh" >> /home/${CodeEditorUser}/.bashrc

                  # Always start in workshop directory
                  echo "cd ${HomeFolder} 2>/dev/null" >> /home/${CodeEditorUser}/.bashrc
          
          - name: CreateWorkshopInstructions
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  # Create README with essential instructions
                  cat > /workshop/README.md << 'EOFREADME'
                  # DAT406 - Blaize Bazaar Workshop

                  ## ðŸš€ Your app is already running!
                  Access it at: https://YOUR_CLOUDFRONT_URL/app/

                  ## Quick Commands

                  **Test database connection:**
                  ```bash
                  python test_connection.py
                  ```

                  **Make changes and rebuild:**
                  ```bash
                  cd /workshop/blaize-bazaar
                  # Edit files in VS Code
                  ~/rebuild-app.sh
                  ```

                  **Connect to PostgreSQL:**
                  ```bash
                  psql
                  ```

                  ## File Locations
                  - App source: `/workshop/blaize-bazaar/src/`
                  - Deployed app: `/var/www/html/app/`

                  ## Troubleshooting
                  - Blank page? Hard refresh: Cmd+Shift+R (Mac) or Ctrl+Shift+R (PC)
                  - Add ?v=1, ?v=2 to URL to bypass cache
                  EOFREADME

                  chmod 644 /workshop/README.md
                  chown ${CodeEditorUser}:${CodeEditorUser} /workshop/README.md

                  # Create simple startup message
                  cat > /home/${CodeEditorUser}/.workshop_welcome << 'EOFWELCOME'
                  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  echo "   ðŸš€ DAT406 Workshop - Your Blaize Bazaar app is ready!"
                  echo "   ðŸ“± Access at: https://YOUR_CLOUDFRONT_URL/app/"
                  echo "   ðŸ“ Make changes: cd /workshop/blaize-bazaar"
                  echo "   ðŸ”¨ Rebuild: ~/rebuild-app.sh"
                  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  EOFWELCOME

                  chmod +x /home/${CodeEditorUser}/.workshop_welcome
                  chown ${CodeEditorUser}:${CodeEditorUser} /home/${CodeEditorUser}/.workshop_welcome

                  # Add to bashrc for first terminal only
                  echo "" >> /home/${CodeEditorUser}/.bashrc
                  echo "[ -z \$WELCOMED ] && export WELCOMED=1 && source ~/.workshop_welcome" >> /home/${CodeEditorUser}/.bashrc
                  echo "cd /workshop 2>/dev/null" >> /home/${CodeEditorUser}/.bashrc

  # Security Group for Code Editor
  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for Code Editor with React dev server
      VpcId: !Ref VPCId
      SecurityGroupIngress:
        - Description: Allow HTTP from CloudFront
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourcePrefixListId: !FindInMap [AWSRegionsPrefixListID, !Ref 'AWS::Region', PrefixList]
        - Description: Allow access from within VPC
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: !Ref VpcCIDR
      SecurityGroupEgress:
        - Description: Allow all outbound traffic
          IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # IAM Role for EC2 Instance
  CodeEditorInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
                - ssm.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
        - arn:aws:iam::aws:policy/ReadOnlyAccess
      Policies:
        - PolicyName: WorkshopAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                Resource:
                  - !Sub 'arn:aws:s3:::${AssetsBucketName}/*'
                  - !Sub 'arn:aws:s3:::${AssetsBucketName}'
                Resource: '*'
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Resource: '*'

  # Instance Profile
  CodeEditorInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref CodeEditorInstanceRole

  # EC2 Instance
  CodeEditorInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref CodeEditorInstanceProfile
      SubnetId: !Ref SubnetId
      SecurityGroupIds:
        - !Ref SecurityGroup
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: !Ref InstanceVolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
            Encrypted: true
      Monitoring: true
      Tags:
        - Key: Name
          Value: !Ref InstanceName
        - Key: Workshop
          Value: DAT406
      UserData:
        Fn::Base64: !Sub |
          #cloud-config
          hostname: ${InstanceName}
          runcmd:
            - mkdir -p ${HomeFolder} && chown -R ${CodeEditorUser}:${CodeEditorUser} ${HomeFolder}

  # Lambda for running SSM document
  SSMDocLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMDocOnEC2
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/${CodeEditorSSMDoc}
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/AmazonCloudWatch-ManageAgent
                  - !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/${CodeEditorInstance}
              - Effect: Allow
                Action:
                  - ssm:ListCommandInvocations
                  - ssm:GetCommandInvocation
                Resource: '*'

  RunSSMDocLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Run SSM document on EC2 instance
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 900
      Environment:
        Variables:
          RetrySleep: 2900
          AbortTimeRemaining: 3200
      Architectures:
        - arm64
      Role: !GetAtt SSMDocLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.debug(f'event: {event}')
              if event['RequestType'] != 'Create':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
              else:
                  sleep_ms = int(os.environ.get('RetrySleep'))
                  abort_time_remaining_ms = int(os.environ.get('AbortTimeRemaining'))
                  resource_properties = event['ResourceProperties']
                  instance_id = resource_properties['InstanceId']
                  document_name = resource_properties['DocumentName']
                  cloudwatch_log_group_name = resource_properties['CloudWatchLogGroupName']

                  logger.info(f'Running SSM Document {document_name} on EC2 instance {instance_id}.')

                  del resource_properties['ServiceToken']
                  if 'ServiceTimeout' in resource_properties:
                      del resource_properties['ServiceTimeout']
                  del resource_properties['InstanceId']
                  del resource_properties['DocumentName']
                  del resource_properties['CloudWatchLogGroupName']

                  parameters = {}
                  for key, value in resource_properties.items():
                      parameters[key] = [value]

                  retry = True
                  attempt_no = 0
                  time_remaining_ms = context.get_remaining_time_in_millis()
                  ssm = boto3.client('ssm')

                  while (retry == True):
                      attempt_no += 1
                      logger.info(f'Attempt: {attempt_no}. Time Remaining: {time_remaining_ms/1000}s')
                      try:
                          response = ssm.send_command(
                              InstanceIds = [instance_id],
                              DocumentName = document_name,
                              CloudWatchOutputConfig = {'CloudWatchLogGroupName': cloudwatch_log_group_name, 'CloudWatchOutputEnabled': True},
                              Parameters = parameters
                          )
                          command_id = response['Command']['CommandId']
                          responseData = {'CommandId': command_id}
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, reason='OK')
                          retry = False

                      except ssm.exceptions.InvalidInstanceId as e:
                          time_remaining_ms = context.get_remaining_time_in_millis()
                          if (time_remaining_ms > abort_time_remaining_ms):
                              logger.info(f'Instance {instance_id} not ready. Sleeping: {sleep_ms/1000}s')
                              time.sleep(sleep_ms/1000)
                              retry = True
                          else:
                              logger.info(f'Instance {instance_id} not ready, timed out.')
                              cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason='Timed out')
                              retry = False

                      except Exception as e:
                          logger.error(e, exc_info=True)
                          cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))
                          retry = False

  # CloudFront Cache Policy
  CodeEditorInstanceCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        DefaultTTL: 86400
        MaxTTL: 31536000
        MinTTL: 1
        Name: !Sub
        - ${InstanceName}-${RandomGUID}
        - RandomGUID: !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId ]]]]
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: all
          EnableAcceptEncodingGzip: False
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers:
              - Accept-Charset
              - Authorization
              - Origin
              - Accept
              - Referer
              - Host
              - Accept-Language
              - Accept-Encoding
              - Accept-Datetime
          QueryStringsConfig:
            QueryStringBehavior: all

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: True
        HttpVersion: http2and3
        CacheBehaviors:
          - AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
              - PUT
              - PATCH
              - POST
              - DELETE
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
            Compress: False
            OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
            TargetOriginId: !Sub CloudFront-${AWS::StackName}
            ViewerProtocolPolicy: allow-all
            PathPattern: '/proxy/*'
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - PATCH
            - POST
            - DELETE
          CachePolicyId: !Ref CodeEditorInstanceCachePolicy
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
          TargetOriginId: !Sub CloudFront-${AWS::StackName}
          ViewerProtocolPolicy: allow-all
        Origins:
          - DomainName: !GetAtt CodeEditorInstance.PublicDnsName
            Id: !Sub CloudFront-${AWS::StackName}
            CustomOriginConfig:
              OriginProtocolPolicy: http-only

  # Run SSM Document
  RunCodeEditorSSMDoc:
    Type: Custom::RunSSMDocLambda
    DependsOn:
      - CodeEditorInstance
      - CodeEditorSSMDoc
    Properties:
      ServiceToken: !GetAtt RunSSMDocLambda.Arn
      ServiceTimeout: 905
      InstanceId: !Ref CodeEditorInstance
      DocumentName: !Ref CodeEditorSSMDoc
      CloudWatchLogGroupName: !Sub /aws/ssm/${CodeEditorSSMDoc}
      CodeEditorPassword: !GetAtt SecretPlaintext.password
      DBSecretArn: !If [HasDBSecret, !Ref DBSecretArn, 'none']

  # Health Check Lambda
  CodeEditorHealthCheckLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  CodeEditorHealthCheckLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Run health check on Code Editor instance
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 600
      Environment:
        Variables:
          RetrySleep: 2900
          AbortTimeRemaining: 5000
      Architectures:
        - arm64
      Role: !GetAtt CodeEditorHealthCheckLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import cfnresponse
          import logging
          import time
          import os
          import http.client
          from urllib.parse import urlparse

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def healthURLOk(url):
              try:
                  logger.debug(f'url: {url}')
                  parsed_url = urlparse(url)
                  if parsed_url.scheme == 'https':
                      conn = http.client.HTTPSConnection(parsed_url.netloc)
                  else:
                      conn = http.client.HTTPConnection(parsed_url.netloc)
                  conn.request("GET", parsed_url.path or "/")
                  response = conn.getresponse()
                  content = response.read()
                  if 200 <= response.status < 400:
                      response_dict = json.loads(content.decode('utf-8'))
                      if 'hasActiveConnections' in response_dict:
                          logger.info('Health check OK.')
                          return True
                      else:
                          logger.info(f'Health check failed. Response: {response_dict}')
                          return False
                  else:
                      logger.info(f'Healthcheck failed. Return code: {response.status}')
                      return False

              except Exception as e:
                  logger.error(e, exc_info=True)
                  return False

              finally:
                  if 'conn' in locals():
                      conn.close()

          def lambda_handler(event, context):
              logger.debug(f'event: {event}')
              try:
                  if event['RequestType'] != 'Create':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
                  else:
                      sleep_ms = int(os.environ.get('RetrySleep'))
                      abort_time_remaining_ms = int(os.environ.get('AbortTimeRemaining'))
                      resource_properties = event['ResourceProperties']
                      url = resource_properties['Url']

                      logger.info(f'Testing url: {url}')

                      time_remaining_ms = context.get_remaining_time_in_millis()
                      attempt_no = 0
                      health_check = False
                      while (attempt_no == 0 or (time_remaining_ms > abort_time_remaining_ms and not health_check)):
                          attempt_no += 1
                          logger.info(f'Attempt: {attempt_no}. Time Remaining: {time_remaining_ms/1000}s')
                          health_check = healthURLOk(url)
                          if not health_check:
                              time.sleep(sleep_ms/1000)
                          time_remaining_ms = context.get_remaining_time_in_millis()
                      if health_check:
                          logger.info(f'Health check successful.')
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='Code Editor healthcheck successful')
                      else:
                          logger.info(f'Health check failed.')
                          cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason='Code Editor healthcheck failed')

              except Exception as e:
                  logger.error(e, exc_info=True)
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  # Health Check
  Healthcheck:
    Type: Custom::CodeEditorHealthCheckLambda
    DependsOn:
      - RunCodeEditorSSMDoc
    Properties:
      ServiceToken: !GetAtt CodeEditorHealthCheckLambda.Arn
      ServiceTimeout: 610
      Url: !Sub https://${CloudFrontDistribution.DomainName}/healthz

Outputs:
  URL:
    Description: VS Code Server URL
    Value: !Sub https://${CloudFrontDistribution.DomainName}/?folder=${HomeFolder}&tkn=${SecretPlaintext.password}
  
  Username:
    Description: Code Editor Username
    Value: !GetAtt SecretPlaintext.username
  
  Password:
    Description: Code Editor Password
    Value: !GetAtt SecretPlaintext.password
  
  CloudFrontDomainName:
    Description: CloudFront Domain Name
    Value: !GetAtt CloudFrontDistribution.DomainName